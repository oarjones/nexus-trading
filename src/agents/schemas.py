"""
Message schemas for inter-agent communication.

Defines Pydantic models for all message types exchanged between agents
via Redis pub/sub channels.
"""

from pydantic import BaseModel, Field, field_validator
from datetime import datetime, timezone
from enum import Enum
from typing import Optional
from uuid import uuid4


class MessageType(str, Enum):
    """Types of messages in the system."""
    SIGNAL = "signal"
    RISK_REQUEST = "risk_request"
    RISK_RESPONSE = "risk_response"
    DECISION = "decision"
    ALERT = "alert"
    STATUS = "status"


class Direction(str, Enum):
    """Trading direction."""
    LONG = "long"
    SHORT = "short"
    NEUTRAL = "neutral"


class TradingSignal(BaseModel):
    """
    Trading signal generated by analyst agents.
    
    Represents a potential trading opportunity with entry, stop, and target prices.
    
    Attributes:
        message_id: Unique identifier for message
        timestamp: When signal was generated
        from_agent: Name of agent that generated signal
        symbol: Trading symbol
        direction: Trade direction (long/short/neutral)
        confidence: Confidence score 0.0-1.0
        entry_price: Suggested entry price
        stop_loss: Stop loss price
        take_profit: Take profit target price
        timeframe: Trading timeframe
        reasoning: Human-readable explanation
        indicators: Dict of technical indicators used
        ttl_seconds: Time-to-live for signal validity
    """
    message_id: str = Field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    correlation_id: Optional[str] = Field(default_factory=lambda: str(uuid4()))  # For request tracing
    from_agent: str
    symbol: str
    direction: Direction
    confidence: float = Field(ge=0.0, le=1.0)
    entry_price: float = Field(gt=0)
    stop_loss: float = Field(gt=0)
    take_profit: float = Field(gt=0)
    timeframe: str
    reasoning: str
    indicators: dict
    ttl_seconds: int = Field(default=300, ge=0)
    
    @field_validator('confidence')
    @classmethod
    def validate_confidence(cls, v: float) -> float:
        """Ensure confidence is between 0 and 1."""
        if not 0.0 <= v <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {v}")
        return v
    
    @field_validator('entry_price', 'stop_loss', 'take_profit')
    @classmethod
    def validate_positive_price(cls, v: float) -> float:
        """Ensure prices are positive."""
        if v <= 0:
            raise ValueError(f"Price must be positive, got {v}")
        return v


class RiskRequest(BaseModel):
    """
    Request to Risk Manager for trade validation.
    
    Attributes:
        message_id: Unique identifier
        request_id: ID to track this specific request
        signal: Original trading signal to validate
        capital: Total available capital
        current_positions: List of current open positions
    """
    message_id: str = Field(default_factory=lambda: str(uuid4()))
    request_id: str = Field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    correlation_id: Optional[str] = None  # Inherited from signal for tracing
    signal: TradingSignal
    capital: float = Field(gt=0)
    current_positions: list[dict] = Field(default_factory=list)
    
    @field_validator('capital')
    @classmethod
    def validate_capital(cls, v: float) -> float:
        """Ensure capital is positive."""
        if v <= 0:
            raise ValueError(f"Capital must be positive, got {v}")
        return v


class RiskResponse(BaseModel):
    """
    Response from Risk Manager with approval decision.
    
    Attributes:
        message_id: Unique identifier
        request_id: ID of original request
        timestamp: Response time
        approved: Whether trade is approved
        original_size: Originally calculated position size
        adjusted_size: Final adjusted position size
        adjustments: List of adjustments made
        warnings: Non-critical warnings
        rejection_reason: Reason for rejection if not approved
    """
    message_id: str = Field(default_factory=lambda: str(uuid4()))
    request_id: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    correlation_id: Optional[str] = None  # Inherited from request for tracing
    approved: bool
    original_size: int = Field(ge=0)
    adjusted_size: int = Field(ge=0)
    adjustments: list[dict] = Field(default_factory=list)
    warnings: list[str] = Field(default_factory=list)
    rejection_reason: Optional[str] = None
    
    @field_validator('adjusted_size')
    @classmethod
    def validate_adjusted_vs_original(cls, v: int, info) -> int:
        """Ensure adjusted size doesn't exceed original."""
        if 'original_size' in info.data and v > info.data['original_size']:
            raise ValueError("Adjusted size cannot exceed original size")
        return v


class Decision(BaseModel):
    """
    Final decision from Orchestrator to execute or discard.
    
    Attributes:
        decision_id: Unique identifier
        timestamp: Decision time
        signal: Original signal
        score: Weighted score from all analysts
        action: Action to take (execute/discard)
        size: Final position size to execute
        adjustments: Summary of risk adjustments
        warnings: Warnings from risk manager
        reasoning: Explanation of decision
    """
    decision_id: str = Field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    correlation_id: Optional[str] = None  # Inherited from signal for tracing
    signal: TradingSignal
    score: float = Field(ge=0.0, le=1.0)
    action: str  # "execute" or "discard"
    size: int = Field(ge=0)
    adjustments: list[dict] = Field(default_factory=list)
    warnings: list[str] = Field(default_factory=list)
    reasoning: str
    
    @field_validator('action')
    @classmethod
    def validate_action(cls, v: str) -> str:
        """Ensure action is valid."""
        if v not in ["execute", "discard"]:
            raise ValueError(f"Action must be 'execute' or 'discard', got {v}")
        return v


class Alert(BaseModel):
    """
    Critical alert message.
    
    Attributes:
        alert_id: Unique identifier
        timestamp: Alert time
        from_agent: Agent that generated alert
        severity: Alert severity (info/warning/critical)
        message: Alert message
        context: Additional context data
    """
    alert_id: str = Field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    from_agent: str
    severity: str  # "info", "warning", "critical"
    message: str
    context: dict = Field(default_factory=dict)
    
    @field_validator('severity')
    @classmethod
    def validate_severity(cls, v: str) -> str:
        """Ensure severity is valid."""
        if v not in ["info", "warning", "critical"]:
            raise ValueError(f"Severity must be info/warning/critical, got {v}")
        return v


class AgentStatus(BaseModel):
    """
    Agent status/health message.
    
    Attributes:
        agent_name: Name of agent
        timestamp: Status timestamp
        status: Current status
        last_activity: Last activity timestamp
        metrics: Additional metrics
    """
    agent_name: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    status: str  # "healthy", "degraded", "stopped"
    last_activity: Optional[datetime] = None
    metrics: dict = Field(default_factory=dict)
    
    @field_validator('status')
    @classmethod
    def validate_status(cls, v: str) -> str:
        """Ensure status is valid."""
        if v not in ["healthy", "degraded", "stopped"]:
            raise ValueError(f"Status must be healthy/degraded/stopped, got {v}")
        return v
